---
title: '''Mysql系列3——基础原理2'''
date: 2019-12-25 20:38:12
categories: mysql
tags: mysql
---

**1.Mysql数据目录**
数据终究要存储在磁盘上，因此Mysql数据目录中包含各种文件，例如表空间、表、视图、日志、进程文件等；因此数据库受文件系统的影响：
>* 数据库名称和表名称不得超过文件系统所允许的最大长度
>* 特殊字符问题
>* 文件长度受文件系统最大长度限制

mysql中有几个系统数据库：
>* mysql: 存储了Mysql的用户账户和权限信息，一些存储过程、事件的定义信息，一些日志信息、帮助信息以及时区信息；
>* information_schema: 维护所有其他数据库的信息，是一些描述性信息；
>* performance_schema: mysql服务器运行过程中的一些状态信息；
>* sys: 通过视图形式把information_schema和performance_schema结合起来，可以更方便的了解mysql服务器的一些性能信息；

**2.InnoDB表空间**
表空间中每个也都有一个页号FILE_PAGE_OFFSET，这个页号由4个字节组成，如果页设置大小为默认16kb，则一个表空间最多64TB数据；
表空间分为独立表空间和系统表空间；对于16KB的页来说，连续64个页是一个区，默认1MB空间；一个索引会生成2个段，一个叶子节点段，
一个非叶子节点段；

**3.表单访问方法**
>* const: 通过主键或者唯一二级索引列与常数的等值比较来定位一条记录的访问方法；
>* ref: 搜索条件为二级索引列与常数等值比较，采用二级索引来执行查询的访问方法；
>* ref_or_null: 搜索条件为（二级索引列与常数等值比较）or（二级索引列为null）；
>* range: 二级索引匹配区间值；
>* index: 只需要遍历二级索引记录的访问方法；
>* index merge: 使用多个索引来完成一次查询；
>* all: 全表扫描；

**4.连接**
连接分为内连接和外连接，区别在于：驱动表中的记录即使在被驱动表没有匹配，是否加入到结果集中；<br>
驱动表只访问一次，被驱动表可能被访问多次，访问次数取决于对驱动表执行单表查询后的结果集中的记录数，这种连接执行方式称为嵌套循环连接；尽量减少访问被驱动表的次数；

**5.成本**
mysql中一条查询语句的执行成本是由两个方面组成：IO成本和CPU成本；<br>
mysql执行查询语句前会先分析所有可用方案的执行成本，对比找出成本最低的方案，也就是执行计划；
>1. 根据搜索条件，找出所有可能使用的索引；
>2. 计算全表扫描的代价；
>3. 计算使用不同索引执行查询的代价；
>4. 对比各种执行方案的代价，找出成本最低的那个；

因此需要注意可能存在的索引计算代价花费时间过长造成的负优化，一些成本常数可设置；

**6.统计数据的收集**
InnoDB默认是以表为单位来收集和存储统计数据的，这些统计数据可用是基于磁盘的永久性统计数据，也可以是基于内存的非永久性统计数据；<br>
innodb_stats_persistent控制着使用永久性统计数据还是非永久性统计数据；<br>
innodb_stats_persistent_sample_pages控制着永久性统计数据的采样页面数量；<br>
innodb_stats_transient_sample_pages控制着非永久性统计数据的采样页面数量；<br>
innodb_stats_auto_recalc控制着是否自动重新计算统计数据。

我们可以针对某个具体的表，在创建和修改表时通过指定STATS_PERSISTENT、STATS_AUTO_RECALC、STATS_SAMPLE_PAGES的值来控制相关统计数据属性。

innodb_stats_method决定着在统计某个索引列不重复值的数量时如何对待NULL值。

**7.查询优化（内部）**
>* 条件化简；
>* 外连接消除；
>* 子查询优化；

**8.Explain执行计划**
格式：[explain] [format=json] sql;
optimizer_trace参数可以启用查看详细的执行优化过程；

**9.Buffer Pool**
1. 磁盘太慢，所以要用内存做缓存；Buffer Pool本质是InnoDB向操作系统申请的一段连续的内存空间，可通过innodb_buffer_pool_size来调整大小；<br>
2. Buffer Pool向操作系统申请的连续内存由控制块和缓存页组成，InnoDB使用链表来管理Buffer Pool，free链表中每个节点都代表一个空闲的缓存页，为了快速定位页是否被加载到Buffer Pool，使用表空间号+页号作为key，
缓存页作为value，建立哈希表；<br>
3. Buffer Pool中被修改的页被称为脏页，脏页不会立即刷新，而是加入flush链表，待之后的某个时间点同步到磁盘上；LRU链表分为young和old两个区域；<br>
4. 每个buffer pool中都有各自独立的链表，一个buffer pool实例由若干chunk组成；