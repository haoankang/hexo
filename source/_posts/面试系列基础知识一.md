---
title: '''面试系列基础知识一'''
date: 2019-12-17 10:23:08
categories: 面试
tags: 面试
---
**1.并发问题产生的根源**
1. CPU缓存导致的可见性问题；
2. CPU切换导致的原子性问题；
3. 编译器优化导致的指令重排序问题；

**2.HashMap问题**
1. 基本数据结构：数组+链表；
2. 数据结构根本目的之一是性能；数组都是有下标的，所以查找速度很快，但插入慢；链表只记录下一个元素
   的地址，优势是插入较快；因为HashMap的添加、修改和查询操作都比较频繁，因此使用数组+链表数据结构；
   根据hash算法快速定位数组，插入的数据顺序放到链表中，这样综合效率较高；
3. HashMap的初始化容量机制和扩容机制： 既然HashMap底层是数组，数组初始化时需要指定一个长度，默认
   初始化一个长度16的数组；有个扩容因子，默认0.75，每次扩容时机是：数组长度*负载因子，每次扩容2倍，
   保持数组长度为2的幂次方，因为底层存储用的&；
4. put过程：先对key调用hashCode()得到一个hash值，类型int，然后用hash值与（16-1）进行位运算，从而
   得到数组下标；为了减少哈希碰撞，获取hash时，会先把key的hashcode和它自己无符号右移16位进行异或
   运算，这样是为了扩大特征值，再与(16-1)位运算；
5. 链表过长处理： hashmap已经尽力减少哈希冲突，但是终究还是有冲突，如果一个链表过长会影响查询效率，
   这种情况下，HashMap会把链表结构转换成红黑树，put时，判断当前链表长度是否大于(TREEIFY_THRESHOLD-1)，
   默认(8-1)，当hashmap扩容时，会判断红黑树节点数量是否大于(NTREEIFY_THRESHOLD)，默认(6-1)，会把
   红黑树转换成链表；
6. HashMap的get查询流程：
>>* 先计算key的哈希值；
>>* 通过哈希值定位key存在哪个数组下标；
>>* 找到后看数组下标里面有没有节点，没有就返回null；
>>* 有节点的话，区分节点是红黑树还是链表，然后分别使用对应数据结构的查找方法；
>>* 根据查找的key和节点里面存的key值判断两个key是不是equals()，equals则返回对应的节点，否则继续
匹配下一个节点，直到匹配成功返回节点，或者没有节点匹配后返回null；

**3.ArrayList和LinkedList**


**4.数据结构——树**
1. 二叉树的基本特点：左子节点的值比父节点的值要小，右节点的值比父节点要大，高度决定了它的查找效率；本质是一种
二分算法的实现；二叉树理想查询时间复杂度是O(logN)，最坏是O(N)；不同的插入顺序导致二叉树的高度不一样，查询
效率千差万别，因此产生了平衡二叉树，比较典型的是AVL树和红黑树，AVL树实现复杂且插入和删除性能差，一般用红黑树；
2. 红黑树的定义：任何一个节点都有颜色，红或黑；根节点是黑色的；父节点之间不可能出现两个连续红节点；任何一个节点
向下遍历到其子孙的叶子节点，所经过的黑色节点个数必须相等；空节点被认为是黑色；
3. 红黑树通过旋转完成平衡，添加、删除、查找时间复杂度基本都是O(logN)；
4. B树属于多叉树（平衡多路查找树），排序也是左小右大；B+树是B树基础上衍生的，区别是：B树根节点包含数据，B+树根节点
只能由索引，数据全部在叶子节点；

**5.B树和B+树区别**
>1. B+树单一节点存储的元素更多，使得查询的IO次数更少，更适合做Mysql的底层数据结构；
>2. 所有的查询都要查询到叶子节点，查询性能是稳定的；
>3. 所有的叶子节点形成一个有序链表，更加便于查找；

**6.死锁**
死锁是什么：
>死锁，是指多个进程循环等待他方占有的资源而无限期的僵持下去的局面；

死锁产生的必要条件：
>* 互斥条件：每个资源一段时间只能由一个进程占有；
>* 不可抢占条件：已经分配给一个进程的资源不能强制被抢占，只能被占有它的进程释放；
>* 占有且申请条件：已经得到某个资源的进程申请新的资源；
>* 循环依赖条件：有两个或以上的进程组成一个环路，该环路中的每个进程都在等待下一个进程所占有的资源；

死锁的预防：
>针对死锁的必要条件，打破某些条件；

死锁的避免：
>* 安全序列：系统中的所有进程都能够按照某一种秩序分配资源，并且依次执行完毕，这种进程序列就是安全序列；
>* 银行家算法。

