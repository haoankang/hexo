---
title: '''Mysql系列2——基础原理'''
date: 2019-12-24 14:37:12
categories: mysql
tags: mysql
---
**1.Mysql客户端和服务端通信方式**

>* TCP/IP通信，最常用方式，例如客户端连接：msql -hhost -uusername -ppasswd -P3306 [database]
>* 命令管道和共享内存，windows可选连接方式.
>* Unix域套接字文件，类unix系统可选.

**2.服务端处理客户端请求**

![](/images/Mysql_1.png)
整个过程分为三个部分：连接管理、解析优化、存储引擎.
常用命令：
```sql
show engines;
create table tableName() engine=InnoDB;
alter table tableName engine=MyISAM;
```

**3.服务端参数**

服务端启动参数可以直接在启动时添加，例如mysqld --skip-networking；

服务端启动时读取配置文件my.ini或my.cnf，按照一定顺序读取；

配置文件中，按照分组概念配置，不同启动命令可以读取不同的组；

服务器启动后，有很多系统变量，影响着服务器的行为，显示：show variables [like (匹配项)];

同时服务器启动后，会有状态变量，可以查看服务器的状态：show status [like (匹配项)];

**4.字符集和比较规则**

mysql中UTF-8分为utf8和utf8mb4，utf8是阉割版的utf8，1-3个字节，utf8mb4对应utf8，1-4个字节；
```sql
show character set/charset (like [匹配项]);
show collation (like [匹配项]);
```
mysql中比较规则后缀：_ai和_as区分重音，_ci和_cs区分大小写，_bin以二进制形式比较；

mysql中有4个字符集和比较规则级别：服务器、数据库、表、列；
```sql
编解码过程：
character_set_client: 服务器解码请求时使用字符集
character_set_connection: 服务器处理请求时会把请求字符串从character_set_client转码到character_set_connection;
character_set_result: 服务器向客户端返回结果时使用的字符集
一般建议这三个参数设置一样.
```

**5.InnoDB记录存储结构**
```sql
InnoDB将数据分为若干页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为16kb；
InnoDB数据按行存储，因此有行格式：Compact、Redundant、Dynamic、Compressed;
指定或修改行格式语法：
    CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
    ALTER TABLE 表名 ROW_FORMAT=行格式名称
```
其中Compact和Redundant行格式如下：
![](/images/Mysql_2.png)
Dynamic和Compact行格式类似，不同的地方在于行溢出的处理；Compressed行格式是压缩格式；

一个页一般16Kb，当记录的数据太大存放不了，会存放到其他页，这种情况被称为行溢出，发生行溢出的主要是varchar(m),blob,text；

**6.InnoDB数据页结构**
总的来说，一个InnoDB的数据页被分成7个部分，如下图：

名称 | 中文名 | 占用空间大小 | 简单描述
---|---|---|---
File Header|文件头部|38字节|页的一些通用信息
Page Header|页面头部|56字节|数据页专有的一些信息
Infimum + Supremum|最小记录和最大记录|26字节|两个虚拟的行记录
User Records|用户记录|不确定|实际存储的行记录内容
Free Space|空闲空间|不确定|页中尚未使用的空间
Page Directory|页面目录|不确定|页中的某些记录的相对位置
File Trailer|文件尾部|8字节|校验页是否完整

每个记录的头信息中都有一个next_record属性，从而使页中的属性串成一个单链表；<br>
InnoDB会把页中的记录划分成若干组，每个组的最后一个记录的地址偏移量作为一个槽，存放在Page Directory中，
所以在一个页中根据主键查找非常快，先通过二分法确定该记录所在槽，再通过记录的next_record属性遍历该槽
所在组中的各个记录；<br>
每个数据页的File Header部分都有上一个和下一个页的编号，所有数据页会组成一个双链表；<br>
为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和页面最后修改时对应的LSN值，
如果首部和尾部的校验和LSN校验不成功的话，就说明同步过程出现了问题。

**7.B+树索引**
每个页记录头信息有个record_type属性：
>* 0: 普通用户记录
>* 1: 目录项记录
>* 2: 最小记录
>* 3: 最大记录

InnoDB中，为了检索方便，使用B+树结构管理数据；叶子节点全部是用户数据页，非叶节点都是目录页，目录项记录
只存储主键值和对应的页号，目录项过多又由目录来管理，层层嵌套形成了B+树；<br>
>* 聚簇索引：1.使用记录主键值的大小进行记录和页的排序；2.B+树的叶子节点存储的是完整的用户记录；
>* 二级索引：1.使用非主键列进行记录也页排序；2.B+树叶子节点存储的不是完整用户记录，而是【非主键列+主键】；3.目录项记录中不再是【主键+页号】，而是【非主键列+页号】，需要回表才能找到完整记录；
>* 联合索引：1.例如建一个C2和C3列的联合索引，先把各个记录和页按照C2列进行排序；在C2列相同情况下，采用C3列进行排序；本质上是二级索引，但多个列只有一个索引；

InnoDB中B+树索引的生成是自上而下的，一个B+树索引的根节点自诞生之日起，就不再移动；<br>
MyISAM中，索引也是树形结构，索引与数据分开存储，索引中存储的是主键值+行号，每次查询都需要回表操作；<br>

**8.索引的使用**
1. 首先明确索引代价=空间+时间（增删改），索引适用一些情况，具体问题具体分析；
>* 全值匹配
>* 匹配左边列
>* 匹配范围值
>* 精确匹配第一列并范围匹配另外一列
>* 用于排序、分组
2. 回表代价巨大，如果使用二级索引查询，结果需要二级索引+聚簇索引，且这种情况下聚簇索引通常是随机IO，因此需要回表的记录越多，使用二级索引的性能越低；
3. 为了清除回表的性能损耗，建议查询列表中只包含索引列；
4. 使用索引时需要注意以下事项：
>* 只为用于搜索、排序、分组的列建立索引
>* 为基数大的列建立索引
>* 索引列的类型尽量小
>* 可以只对字符串的前缀建立索引
>* 只有索引列在比较表达式中单独出现才适用索引
>* 为了尽可能减少聚簇索引的页分裂和记录位移，建议主键拥有AUTO_INCREMENT属性
>* 定位并删除表中的重复和冗余索引
>* 尽量使用覆盖索引进行查询，避免回表的性能损耗