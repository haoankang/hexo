---
title: Zookeeper系列3——Zookeeper的使用r的使用和典型应用场景
date: 2019-08-30 10:55:01
categories: zookeeper
tags: zookeeper
---

## 1.部署和运行
zookeeper运行有两种模式，集群模式和单机模式，也可以伪集群，核心是配置config/zoo.cfg，修改client.port和server.*，
配置datapath和datalogpath，在datapath目录下新建文件myid用来确认机器编号；可以修改启动文件，来启用JMX；

## 2.对接、使用方式
2.1 客户端脚本
> 服务端使用zkCli.sh，可以以脚本方式执行相关操作，如增删改查等；
2.2 java客户端API
> ZooKeeper客户端API，以及监听Watcher，多次监听需要重复注册；
2.3 curator开源客户端
> 建议使用，封装较好，且持续更新社区活跃；maven依赖curator-framework,客户端CuratorFramework由CuratorFrameworkFactory创建，使用Fluent风格
编写，可以同步或异步方式.还有一个包curator-recipes中封装了常用的使用场景接口，例如：
事件监听--监听器对应节点NodeCache和子节点PathChildrenCache，Master选举，分布式锁，分布式计数器等实用API.

## 3.典型使用场景及实现
3.1 数据发布/订阅
> 数据发布/订阅系统也就是配置中心，可以实现配置信息的集中管理和数据动态更新，发布/订阅一般两种模式，推(push)模式
和拉(poll)模式；zookeeper采用推拉结合的方式：客户端向服务端注册自己关注的节点，当节点发生变化，服务端会通知
客户端，客户端接收到通知后，再去服务端获取最新数据；

> zookeeper的实现方式：例如数据库切换，可以在zookeeper上选取一个节点初始化，例如/app/dataconfig，节点保存
数据库信息，客户端注册一个watcher监听节点数据变化，如果需要切换变化数据库配置，则利用zk修改数据，同时会自动
通知正在监听的客户端；

3.2 负载均衡
> 负载均衡用来对多个计算机、网络连接、CPU、磁盘驱动器及其他资源进行分配负载，以达到优化资源使用、最大化吞吐率、
最小化相应时间和避免过载的目的；其中比较典型的是DNS服务，zookeeper可以实现DDNS；

>实现方式：创建一个节点进行域名配置，例如/DDNS/app1/server1.com.cn，在这个子节点中写入对应的ip列表，需要RPC
时，先从相应节点获取ip列表，自己解析，同时还可以注册监听ip列表变化；

3.3 命名服务
> 命名服务是分布式系统最基本的公共服务之一，通过使用命名服务，客户端可以根据指定名字获取资源的实体、服务地址和
提供者的信息等；核心思想是在分布式环境中，上层应用需要一个全局唯一的id；UUID的缺点是长度过长且业务意义不明；

> 实现方式：zookeeper的API创建顺序节点时会返回这个节点的完整名字，利用zookeeper的顺序节点ID唯一实现命名服务；

3.4 分布式协调/通知
> 对于一个部署在多台机器上的应用来说，需要一个协调者，控制例如事务处理等，可以解耦从而增强扩展性；

> 实现方式：zookeeper的数据一致性读写和监听可以很方便的实现；分布式系统机器间通信方式有三种类型：心跳检测、
工作进度汇报和系统调度；

3.5 分布式锁
> 分为排他锁和共享锁.

>排他锁的实现：获取锁————创建一个节点/exclusive_lock，相关业务例如业务一需要一个排他锁，则在此节点下创建临时
子节点/exclusive_lock/business_1，利用节点的zookeeper多个机器创建同一节点只有一个创建成功的节点特性，
创建成功则获取锁，同时创建失败的监听此节点；释放锁————获取锁的客户端自己删除节点，或者客户端断开连接zookeeper
服务端会删除临时节点，监听此节点的客户端会收到通知，执行获取锁的逻辑；

>共享锁的实现：共享锁又称为读锁，如果事务T1对对象O加了共享锁，则当前事务只能对O进行读操作，其他事务也只能对O
加共享锁，直到O对象上的所有共享锁全部释放；定义锁————创建一个节点/shared_lock，事务加锁时可以按照下面格式
/shared_lock/business_2/host1-W|R-001，区别读和写；获取锁————需要获取共享锁时，所有客户端都在/shared_lock下创建临时
子节点，并且注册监听/shared_lock/business_2的所有子节点；读请求：判断比自己序列小的节点是否有写锁，如果有则等待；
写请求：判断是否有比自己序列小的节点；释放锁————和排他锁的释放逻辑一样；

>共享锁的羊群效应：因为获取共享锁的节点需要监听/shared_lock/business_2节点的所有子节点，例如当一个节点释放
锁之后，需要通知大量的其他等待客户端，并且其他客户端需要拉取所有子节点列表判断自己是否可以获取锁；短时间如果
有多个节点是否锁，就会引起大量的客户端Watch通知，这就是羊群效应；产生的根本原因是：没有找准客户端的关注点；

>共享锁的改进：理解了羊群效应产生的根本原因，可以如下改进：读共享锁只监听比自己小的写锁节点，写共享锁只监听比
自己小的节点；

